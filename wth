#!/usr/bin/env bash
set -euo pipefail

VERSION="0.3.1"

# ------------------------------------------------------------------------------
# Helper: Return to original directory
# ------------------------------------------------------------------------------
ORIG_DIR="$(pwd)"
finish() {
    cd "$ORIG_DIR" || exit 1
}
trap finish EXIT

# ------------------------------------------------------------------------------
# Helper: die with message
# ------------------------------------------------------------------------------
die() {
    echo "ERROR: $*" >&2
    exit 1
}

# ------------------------------------------------------------------------------
# Command: init
#
# Usage: wth init <repo-url> [project-folder]
#
# Clones the repo into <project-folder>/
# Detaches the primary worktree
# Creates a clean worktree for main at <project-folder>-main/
#
# If project-folder is omitted, it is derived from the repo URL.
# ------------------------------------------------------------------------------
wt_init() {
    [ "$#" -ge 1 ] && [ "$#" -le 2 ] || die "Usage: wth init <repo-url> [project-folder]"

    local repo="$1"
    local proj="${2:-}"

    # Extract project name from repo URL if not provided
    if [ -z "$proj" ]; then
        proj="$(basename "$repo" .git)"
    fi

    if [ -d "$proj" ]; then
        die "Directory '$proj' already exists."
    fi

    echo "Cloning $repo into $proj ..."
    git clone "$repo" "$proj"

    cd "$proj"

    echo "Detaching primary worktree ..."
    git switch --detach

    echo "Creating worktree for main ..."
    git worktree add "../${proj}-main" main

    echo "Initialization finished."
}

# ------------------------------------------------------------------------------
# Command: merge
#
# Usage: wth merge [--push] <feature-worktree-path> [target-branch]
#
# Rebase feature branch onto origin/<target-branch>,
# then merge into target worktree. Push only if --push is specified.
# Exits immediately if conflicts occur.
# ------------------------------------------------------------------------------
wt_merge() {
    local do_push=false

    # Parse --push flag
    if [ "${1:-}" = "--push" ]; then
        do_push=true
        shift
    fi

    [ "$#" -ge 1 ] && [ "$#" -le 2 ] || die "Usage: wth merge [--push] <feature-worktree-path> [target-branch=main]"

    local feature_wt="$1"
    local target_branch="${2:-main}"

    [ -d "$feature_wt" ] || die "Directory '$feature_wt' not found."

    cd "$feature_wt"

    # Determine branch automatically
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD)"

    if [ "$branch" = "HEAD" ]; then
        die "Feature worktree is in detached HEAD state."
    fi

    echo "Feature branch: $branch"
    echo "Target branch: $target_branch"

    echo "Fetching updates ..."
    git fetch origin

    echo "Rebasing $branch onto origin/$target_branch ..."
    if ! git rebase "origin/$target_branch"; then
        echo ""
        echo "CONFLICTS DETECTED â€” aborting rebase and stopping."
        git rebase --abort || true
        exit 1
    fi

    echo "Rebase successful."

    echo "Locating $target_branch worktree ..."
    # Find a worktree whose branch matches target_branch
    # git worktree list output format: /path/to/wt  <commit> [branch] or (detached HEAD)
    local target_wt=""
    while read -r wt; do
        local path branchname
        path="$(echo "$wt" | awk '{print $1}')"
        # Extract branch name from [branch] format, removing brackets
        branchname="$(echo "$wt" | awk '{print $3}' | tr -d '[]')"

        if [ "$branchname" = "$target_branch" ]; then
            target_wt="$path"
            break
        fi
    done < <(git worktree list)

    [ -n "$target_wt" ] || die "Could not locate a worktree with branch '$target_branch'."

    echo "Target worktree: $target_wt"

    echo "Merging feature branch into $target_branch ..."
    cd "$target_wt"

    git pull origin "$target_branch"

    if ! git merge --ff-only "$branch"; then
        die "Cannot fast-forward merge. Ensure feature branch is rebased cleanly."
    fi

    if [ "$do_push" = true ]; then
        echo "Pushing to origin/$target_branch ..."
        git push origin "$target_branch"
    fi

    echo "Merge completed successfully."
}

# ------------------------------------------------------------------------------
# Command: clean
#
# Usage: wth clean <feature-worktree-path>
#
# Removes the worktree, deletes the local branch, deletes the remote branch,
# prunes stale refs.
# ------------------------------------------------------------------------------
wt_clean() {
    [ "$#" -eq 1 ] || die "Usage: wth clean <feature-worktree-path>"

    local feature_wt="$1"
    [ -d "$feature_wt" ] || die "Directory '$feature_wt' does not exist."

    # Identify branch and primary git dir before removing worktree
    cd "$feature_wt"
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD)"
    if [ "$branch" = "HEAD" ]; then
        die "Worktree is in detached HEAD; no branch to remove."
    fi

    # Get path to primary git directory (works from any worktree)
    local git_common_dir
    git_common_dir="$(git rev-parse --git-common-dir)"

    echo "Cleaning branch $branch at worktree $feature_wt"

    # Change to original directory before removing worktree
    cd "$ORIG_DIR"

    # Remove worktree
    echo "Removing worktree directory ..."
    git -C "$git_common_dir" worktree remove "$feature_wt" || true

    # Delete local branch
    echo "Deleting local branch $branch ..."
    git -C "$git_common_dir" branch -d "$branch" || git -C "$git_common_dir" branch -D "$branch"

    # Delete remote branch (if exists)
    if git -C "$git_common_dir" ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
        echo "Deleting remote branch ..."
        git -C "$git_common_dir" push origin --delete "$branch" || true
    fi

    # Prune stale refs
    echo "Pruning stale remote refs ..."
    git -C "$git_common_dir" fetch --prune

    echo "Cleanup completed."
}

# ------------------------------------------------------------------------------
# Command: add
#
# Usage: wth add <existing-worktree-path> <new-worktree-name>
#
# Creates a new worktree with a new branch of the same name.
# Can be run from anywhere. The new worktree is created as a sibling
# to the specified existing worktree.
# ------------------------------------------------------------------------------
wt_add() {
    [ "$#" -eq 2 ] || die "Usage: wth add <existing-worktree-path> <new-worktree-name>"

    local ref_wt="$1"
    local name="$2"

    [ -d "$ref_wt" ] || die "Directory '$ref_wt' does not exist."

    # Change into reference worktree to get paths
    cd "$ref_wt"

    # Get the worktree root (always absolute)
    local worktree_root
    worktree_root="$(git rev-parse --show-toplevel)"

    # Get path to primary git directory
    # May be relative (e.g., ".git") so we make it absolute
    local git_common_dir
    git_common_dir="$(git rev-parse --git-common-dir)"
    case "$git_common_dir" in
        /*) ;; # already absolute
        *)  git_common_dir="$worktree_root/$git_common_dir" ;;
    esac

    # Return to original directory before creating worktree
    cd "$ORIG_DIR"

    # Create new worktree as sibling to reference worktree
    local parent_dir
    parent_dir="$(dirname "$worktree_root")"

    local worktree_path="$parent_dir/$name"

    if [ -d "$worktree_path" ]; then
        die "Directory '$worktree_path' already exists."
    fi

    echo "Creating worktree '$name' at $worktree_path ..."
    git -C "$git_common_dir" worktree add "$worktree_path" -b "$name"

    echo "Worktree created successfully."
    echo "cd $worktree_path"
}

# ------------------------------------------------------------------------------
# Command dispatcher
# ------------------------------------------------------------------------------
case "${1:-}" in
    -v|--version)
        echo "$VERSION"
        ;;
    init)  shift; wt_init "$@" ;;
    add)   shift; wt_add "$@" ;;
    merge) shift; wt_merge "$@" ;;
    clean) shift; wt_clean "$@" ;;
    *)
        echo "wth $VERSION - Git worktree helper"
        echo ""
        echo "Usage:"
        echo "  wth init  <repo-url> [project-folder]"
        echo "  wth add   <existing-worktree-path> <new-worktree-name>"
        echo "  wth merge [--push] <feature-worktree-path> [target-branch=main]"
        echo "  wth clean <feature-worktree-path>"
        exit 1
        ;;
esac
